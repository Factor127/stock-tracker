<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Stock Trading Tracker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .main-content {
            padding: 30px;
        }
        .add-stock-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }
        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .input-group input, .input-group select {
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-width: 150px;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }
        .btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }
        .btn-danger:hover {
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        }
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            margin-left: 10px;
        }
        .btn-secondary:hover {
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        }
        .stocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .stock-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }
        .stock-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        .stock-header {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            padding: 20px;
            position: relative;
        }
        .stock-symbol {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stock-price {
            font-size: 1.3rem;
            opacity: 0.9;
        }
        .stock-body {
            padding: 20px;
        }
        .analysis-section {
            margin-bottom: 20px;
        }
        .analysis-section h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .analysis-item {
            background: #f8f9fa;
            padding: 10px 15px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        .analysis-item.warning {
            border-left-color: #ff9800;
            background: #fff3e0;
        }
        .analysis-item.danger {
            border-left-color: #f44336;
            background: #ffebee;
        }
        .analysis-item.strong {
            border-left-color: #2e7d32;
            background: #e8f5e8;
            font-weight: bold;
        }
        .alert {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        .alert.success {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
        }
        .alert.info {
            background: linear-gradient(135deg, #2196F3 0%, #1565C0 100%);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .chart-link {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 15px;
            border-radius: 6px;
            text-decoration: none;
            margin: 10px 0;
            font-weight: 500;
        }
        .chart-link:hover {
            background: #bbdefb;
        }
        .remove-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .error {
            background: #ffcdd2;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .douglas-principles {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #4CAF50;
        }
        .douglas-principles h5 {
            color: #2e7d32;
            margin-bottom: 8px;
        }
        .last-updated {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 15px;
        }
        .strategy-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #ffcc02;
        }
        .strategy-box h5 {
            color: #ef6c00;
            margin-bottom: 10px;
        }
        .historical-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #1565c0;
        }
        /* Simple Explanation Modal Styles */
        .explanation-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        .explanation-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
        }
        .explanation-header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 20px;
            margin: -30px -30px 30px -30px;
            border-radius: 20px 20px 0 0;
            text-align: center;
        }
        .explanation-header h2 {
            margin: 0;
            font-size: 1.8rem;
        }
        .close-explanation {
            position: absolute;
            top: 15px;
            right: 25px;
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }
        .close-explanation:hover {
            opacity: 0.7;
        }
        .simple-explanation {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #333;
        }
        .simple-explanation h3 {
            color: #2e7d32;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        .simple-explanation .key-point {
            background: #f0f7ff;
            padding: 15px;
            border-left: 4px solid #2196F3;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        .simple-explanation .action-item {
            background: #fff3e0;
            padding: 15px;
            border-left: 4px solid #ff9800;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            font-weight: bold;
        }
        .simple-explanation .analogy {
            background: #f3e5f5;
            padding: 15px;
            border-left: 4px solid #9c27b0;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .stocks-grid {
                grid-template-columns: 1fr;
            }
            .input-group {
                flex-direction: column;
            }
            .header h1 {
                font-size: 2rem;
            }
            .explanation-content {
                margin: 2% auto;
                width: 95%;
                padding: 20px;
            }
            .explanation-header {
                margin: -20px -20px 20px -20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìà Smart Stock Trading Tracker</h1>
            <p>Track opportunities using Mark Douglas trading principles</p>
            <div style="font-size: 0.9rem; margin-top: 15px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;">
                üì° <strong>Enhanced with Historical Analysis:</strong> This tracker now analyzes 6 months of historical data to identify REAL support and resistance levels based on multiple price touches and volume confirmation.
            </div>
        </div>
        <div class="main-content">
            <div class="add-stock-section">
                <h3>Add Stock to Track</h3>
                <div class="input-group">
                    <input type="text" id="stockSymbol" placeholder="Stock Symbol (e.g., AAPL)" maxlength="10">
                    <select id="strategy">
                        <option value="range">Range Trading (Buy Support/Sell Resistance)</option>
                        <option value="breakout">Breakout Trading</option>
                        <option value="trend">Trend Following</option>
                        <option value="reversal">Reversal Trading</option>
                    </select>
                    <input type="number" id="riskPercent" placeholder="Risk % (1-5)" min="0.5" max="10" step="0.5" value="2">
                    <button class="btn" onclick="addStock()">Add Stock</button>
                </div>
                <div class="input-group" style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px;">
                    <input type="password" id="claudeApiKey" placeholder="Claude API Key (stored locally)" style="flex: 1;">
                    <button class="btn btn-secondary" onclick="saveApiKey()">Save API Key</button>
                    <span id="apiKeyStatus" style="margin-left: 10px; font-weight: bold;"></span>
                </div>
                <div class="input-group">
                    <input type="text" id="proxyUrl" placeholder="Proxy URL (e.g., https://your-app.vercel.app/api/proxy)" style="flex: 1;">
                    <button class="btn btn-secondary" onclick="saveProxyUrl()">Save Proxy URL</button>
                    <span id="proxyStatus" style="margin-left: 10px; font-weight: bold;"></span>
                </div>
                <div class="input-group">
                    <input type="text" id="proxyUrl" placeholder="Proxy URL (e.g., https://your-app.vercel.app/api/claude-proxy)" style="flex: 1;">
                    <button class="btn btn-secondary" onclick="saveProxyUrl()">Save Proxy URL</button>
                    <span id="proxyStatus" style="margin-left: 10px; font-weight: bold;"></span>
                </div>
                <div id="addStockError"></div>
            </div>
            <div id="stocksContainer" class="stocks-grid">
                <!-- Stocks will be added here -->
            </div>
        </div>
    </div>

    <!-- Simple Explanation Modal -->
    <div id="explanationModal" class="explanation-modal">
        <div class="explanation-content">
            <div class="explanation-header">
                <span class="close-explanation" onclick="closeExplanation()">&times;</span>
                <h2>üß† Simple Explanation</h2>
            </div>
            <div id="explanationText" class="simple-explanation">
                <!-- Explanation content will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ====== ENHANCED HISTORICAL ANALYSIS SCRIPT ======
        let trackedStocks = [];
        const ALPHA_VANTAGE_KEY = 'CYWU5AB73MHCXLM0';
        const FMP_KEY = 'kCTs1LZBDqjgAuq2XsrbLdMInyG7jnmx';

        window.onload = function() {
            loadTrackedStocks();
            displayStocks();
            setInterval(checkAllStocksForAlerts, 3600000);
        };

        function loadTrackedStocks() {
            const stored = localStorage.getItem('trackedStocks');
            if (stored) trackedStocks = JSON.parse(stored);
        }

        function saveTrackedStocks() {
            localStorage.setItem('trackedStocks', JSON.stringify(trackedStocks));
        }

        async function addStock() {
            const symbol = document.getElementById('stockSymbol').value.toUpperCase().trim();
            const strategy = document.getElementById('strategy').value;
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
            const errorDiv = document.getElementById('addStockError');
            errorDiv.innerHTML = '';

            if (!symbol) {
                errorDiv.innerHTML = '<div class="error">Please enter a stock symbol</div>';
                return;
            }
            if (trackedStocks.find(s => s.symbol === symbol)) {
                errorDiv.innerHTML = '<div class="error">This stock is already being tracked</div>';
                return;
            }
            try {
                errorDiv.innerHTML = '<div class="loading">Fetching real-time data and analyzing 6 months of history...</div>';
                
                // Get both current and historical data
                const [currentData, historicalData] = await Promise.all([
                    fetchCurrentStockData(symbol),
                    fetchHistoricalData(symbol)
                ]);
                
                if (!currentData) throw new Error('Unable to fetch current stock data');
                if (!historicalData || historicalData.length < 30) throw new Error('Unable to fetch sufficient historical data');
                
                const analysis = analyzeStockWithHistory(currentData, historicalData, strategy);
                const newStock = {
                    symbol: symbol,
                    strategy: strategy,
                    riskPercent: riskPercent,
                    data: currentData,
                    historicalData: historicalData,
                    analysis: analysis,
                    alerts: [],
                    dateAdded: new Date().toISOString(),
                    lastUpdated: new Date().toISOString()
                };
                trackedStocks.push(newStock);
                saveTrackedStocks();
                displayStocks();
                document.getElementById('stockSymbol').value = '';
                errorDiv.innerHTML = '';
            } catch (error) {
                errorDiv.innerHTML = `<div class="error">Error adding stock: ${error.message}</div>`;
            }
        }

        async function fetchCurrentStockData(symbol) {
            // Try multiple real data sources for current data
            const dataSources = [
                { name: 'Yahoo Finance', func: () => fetchFromYahooFinance(symbol) },
                { name: 'Alpha Vantage', func: () => fetchFromAlphaVantage(symbol) },
                { name: 'Financial Modeling Prep', func: () => fetchFromFinancialModelingPrep(symbol) }
            ];
            
            for (const source of dataSources) {
                try {
                    const data = await source.func();
                    if (data && data.currentPrice && data.currentPrice > 0) {
                        return data;
                    }
                } catch (error) {
                    console.log(`${source.name} failed: ${error.message}`);
                }
            }
            throw new Error('Unable to fetch current stock data from any source');
        }

        async function fetchHistoricalData(symbol, months = 6) {
            // Try Yahoo Finance first (free and reliable)
            try {
                return await fetchHistoricalFromYahoo(symbol, months);
            } catch (error) {
                console.log('Yahoo historical failed:', error.message);
            }
            
            // Fallback to Alpha Vantage
            try {
                return await fetchHistoricalFromAlphaVantage(symbol);
            } catch (error) {
                console.log('Alpha Vantage historical failed:', error.message);
            }
            
            throw new Error('Unable to fetch historical data from any source');
        }

        async function fetchHistoricalFromYahoo(symbol, months = 6) {
            const proxyUrl = localStorage.getItem('proxyUrl');
            if (!proxyUrl) {
                throw new Error('Proxy URL not configured');
            }

            const endDate = Math.floor(Date.now() / 1000);
            const startDate = endDate - (months * 30 * 24 * 60 * 60);
            
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${startDate}&period2=${endDate}&interval=1d`;
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'stock', url: url })
            });

            if (!response.ok) throw new Error('Yahoo Finance historical API failed');
            
            const data = await response.json();
            const result = data.chart?.result?.[0];
            if (!result) throw new Error('No historical data from Yahoo Finance');
            
            const timestamps = result.timestamp;
            const quotes = result.indicators.quote[0];
            const volumes = quotes.volume;
            
            const historicalData = [];
            for (let i = 0; i < timestamps.length; i++) {
                if (quotes.high[i] && quotes.low[i] && quotes.open[i] && quotes.close[i]) {
                    historicalData.push({
                        date: new Date(timestamps[i] * 1000).toISOString().split('T')[0],
                        open: +quotes.open[i].toFixed(2),
                        high: +quotes.high[i].toFixed(2),
                        low: +quotes.low[i].toFixed(2),
                        close: +quotes.close[i].toFixed(2),
                        volume: volumes[i] || 0
                    });
                }
            }
            
            return historicalData;
        }

        async function fetchHistoricalFromAlphaVantage(symbol) {
            const proxyUrl = localStorage.getItem('proxyUrl');
            if (!proxyUrl) {
                throw new Error('Proxy URL not configured');
            }

            const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=full&apikey=${ALPHA_VANTAGE_KEY}`;
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'stock', url: url })
            });

            if (!response.ok) throw new Error('Alpha Vantage historical API failed');
            
            const data = await response.json();
            const timeSeries = data['Time Series (Daily)'];
            if (!timeSeries) throw new Error('No historical data from Alpha Vantage');
            
            const historicalData = [];
            const dates = Object.keys(timeSeries).slice(0, 180); // Last 6 months
            
            for (const date of dates) {
                const dayData = timeSeries[date];
                historicalData.push({
                    date: date,
                    open: +parseFloat(dayData['1. open']).toFixed(2),
                    high: +parseFloat(dayData['2. high']).toFixed(2),
                    low: +parseFloat(dayData['3. low']).toFixed(2),
                    close: +parseFloat(dayData['4. close']).toFixed(2),
                    volume: parseInt(dayData['5. volume'])
                });
            }
            
            return historicalData.reverse(); // Chronological order
        }

        async function fetchFromYahooFinance(symbol) {
            const proxyUrl = localStorage.getItem('proxyUrl');
            if (!proxyUrl) {
                throw new Error('Proxy URL not configured');
            }

            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`;
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'stock', url: url })
            });

            if (!response.ok) throw new Error('Yahoo Finance API failed');
            const data = await response.json();
            const result = data.chart?.result?.[0];
            if (!result) throw new Error('No data from Yahoo Finance');
            const meta = result.meta;
            const currentPrice = meta.regularMarketPrice || meta.previousClose;
            const previousClose = meta.previousClose;
            return {
                symbol: symbol,
                currentPrice: +currentPrice.toFixed(2),
                open: +(meta.regularMarketOpen || currentPrice).toFixed(2),
                high: +(meta.regularMarketDayHigh || currentPrice).toFixed(2),
                low: +(meta.regularMarketDayLow || currentPrice).toFixed(2),
                volume: meta.regularMarketVolume || 0,
                change: +(currentPrice - previousClose).toFixed(2),
                changePercent: +(((currentPrice - previousClose) / previousClose) * 100).toFixed(2),
                previousClose: +previousClose.toFixed(2)
            };
        }

        async function fetchFromAlphaVantage(symbol) {
            const proxyUrl = localStorage.getItem('proxyUrl');
            if (!proxyUrl) {
                throw new Error('Proxy URL not configured');
            }

            const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${ALPHA_VANTAGE_KEY}`;
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'stock', url: url })
            });

            if (!response.ok) throw new Error('Alpha Vantage API failed');
            const data = await response.json();
            const quote = data['Global Quote'];
            if (!quote) throw new Error('No data from Alpha Vantage');
            const currentPrice = parseFloat(quote['05. price']);
            const previousClose = parseFloat(quote['08. previous close']);
            return {
                symbol: symbol,
                currentPrice: +currentPrice.toFixed(2),
                open: +parseFloat(quote['02. open']).toFixed(2),
                high: +parseFloat(quote['03. high']).toFixed(2),
                low: +parseFloat(quote['04. low']).toFixed(2),
                volume: parseInt(quote['06. volume']),
                change: +parseFloat(quote['09. change']).toFixed(2),
                changePercent: +parseFloat(quote['10. change percent'].replace('%', '')).toFixed(2),
                previousClose: +previousClose.toFixed(2)
            };
        }

        async function fetchFromFinancialModelingPrep(symbol) {
            const proxyUrl = localStorage.getItem('proxyUrl');
            if (!proxyUrl) {
                throw new Error('Proxy URL not configured');
            }

            const url = `https://financialmodelingprep.com/api/v3/quote/${symbol}?apikey=${FMP_KEY}`;
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'stock', url: url })
            });

            if (!response.ok) throw new Error('Financial Modeling Prep API failed');
            const data = await response.json();
            if (!data || data.length === 0) throw new Error('No data from Financial Modeling Prep');
            const quote = data[0];
            return {
                symbol: symbol,
                currentPrice: +quote.price.toFixed(2),
                open: +quote.open.toFixed(2),
                high: +quote.dayHigh.toFixed(2),
                low: +quote.dayLow.toFixed(2),
                volume: quote.volume,
                change: +quote.change.toFixed(2),
                changePercent: +quote.changesPercentage.toFixed(2),
                previousClose: +quote.previousClose.toFixed(2)
            };
        }

        function analyzeStockWithHistory(currentData, historicalData, strategy) {
            const analysis = {
                strategy: strategy,
                signals: [],
                levels: {},
                douglasPrinciples: {},
                recommendation: '',
                riskLevel: 'Medium',
                historicalAnalysis: {}
            };

            // Calculate real support and resistance from historical data
            const supportResistanceLevels = findSupportResistanceLevels(historicalData);
            analysis.levels = supportResistanceLevels;
            
            // Analyze trend and patterns
            const trendAnalysis = analyzeTrend(historicalData);
            analysis.historicalAnalysis = trendAnalysis;
            
            // Get specific strategy analysis
            const strategyAnalysis = getStrategyAnalysis(currentData, analysis.levels, trendAnalysis, strategy);
            Object.assign(analysis, strategyAnalysis);
            
            // Douglas principles
            analysis.douglasPrinciples = {
                edge: `${strategy} strategy based on ${analysis.levels.supportLevels.length} support and ${analysis.levels.resistanceLevels.length} resistance levels from 6-month analysis`,
                probability: `Historical data shows ${analysis.historicalAnalysis.trendStrength}% confidence in current ${analysis.historicalAnalysis.currentTrend} trend`,
                riskAcceptance: `Stop loss calculated at nearest major level: $${analysis.levels.stopLoss || 'TBD'}`,
                execution: `Entry signals based on real price levels tested ${analysis.levels.strongestSupport?.touches || 'multiple'} times`
            };

            return analysis;
        }

        function findSupportResistanceLevels(historicalData) {
            const levels = {
                supportLevels: [],
                resistanceLevels: [],
                strongestSupport: null,
                strongestResistance: null,
                currentSupport: null,
                currentResistance: null
            };

            // Get all significant highs and lows
            const swingPoints = findSwingPoints(historicalData);
            
            // Group similar price levels (within 2% of each other)
            const supportClusters = findPriceClusters(swingPoints.lows, 0.02);
            const resistanceClusters = findPriceClusters(swingPoints.highs, 0.02);
            
            // Convert clusters to support/resistance levels
            levels.supportLevels = supportClusters.map(cluster => ({
                price: cluster.avgPrice,
                touches: cluster.points.length,
                strength: cluster.points.length >= 3 ? 'Strong' : cluster.points.length >= 2 ? 'Moderate' : 'Weak',
                dates: cluster.points.map(p => p.date),
                volumes: cluster.points.map(p => p.volume)
            })).sort((a, b) => b.price - a.price);

            levels.resistanceLevels = resistanceClusters.map(cluster => ({
                price: cluster.avgPrice,
                touches: cluster.points.length,
                strength: cluster.points.length >= 3 ? 'Strong' : cluster.points.length >= 2 ? 'Moderate' : 'Weak',
                dates: cluster.points.map(p => p.date),
                volumes: cluster.points.map(p => p.volume)
            })).sort((a, b) => a.price - b.price);

            // Find strongest levels
            levels.strongestSupport = levels.supportLevels.reduce((strongest, level) => 
                !strongest || level.touches > strongest.touches ? level : strongest, null);
            
            levels.strongestResistance = levels.resistanceLevels.reduce((strongest, level) => 
                !strongest || level.touches > strongest.touches ? level : strongest, null);

            // Find current nearest levels
            const currentPrice = historicalData[historicalData.length - 1].close;
            levels.currentSupport = levels.supportLevels.find(level => level.price < currentPrice);
            levels.currentResistance = levels.resistanceLevels.find(level => level.price > currentPrice);

            // Calculate stop loss and take profit levels
            if (levels.currentSupport) {
                levels.stopLoss = +(levels.currentSupport.price * 0.98).toFixed(2);
            }
            if (levels.currentResistance) {
                levels.takeProfit = +(levels.currentResistance.price * 0.98).toFixed(2);
            }

            return levels;
        }

        function findSwingPoints(historicalData, period = 5) {
            const highs = [];
            const lows = [];

            for (let i = period; i < historicalData.length - period; i++) {
                const current = historicalData[i];
                let isHigh = true;
                let isLow = true;

                // Check if current point is a swing high or low
                for (let j = i - period; j <= i + period; j++) {
                    if (j === i) continue;
                    if (historicalData[j].high > current.high) isHigh = false;
                    if (historicalData[j].low < current.low) isLow = false;
                }

                if (isHigh) {
                    highs.push({
                        price: current.high,
                        date: current.date,
                        volume: current.volume,
                        index: i
                    });
                }

                if (isLow) {
                    lows.push({
                        price: current.low,
                        date: current.date,
                        volume: current.volume,
                        index: i
                    });
                }
            }

            return { highs, lows };
        }

        function findPriceClusters(points, tolerance = 0.02) {
            const clusters = [];
            const used = new Set();

            for (let i = 0; i < points.length; i++) {
                if (used.has(i)) continue;

                const cluster = {
                    points: [points[i]],
                    avgPrice: points[i].price
                };

                // Find all points within tolerance
                for (let j = i + 1; j < points.length; j++) {
                    if (used.has(j)) continue;
                    
                    const priceDiff = Math.abs(points[j].price - cluster.avgPrice) / cluster.avgPrice;
                    if (priceDiff <= tolerance) {
                        cluster.points.push(points[j]);
                        used.add(j);
                    }
                }

                // Recalculate average price
                cluster.avgPrice = +(cluster.points.reduce((sum, p) => sum + p.price, 0) / cluster.points.length).toFixed(2);
                
                // Only include clusters with at least 2 touches
                if (cluster.points.length >= 2) {
                    clusters.push(cluster);
                }
                
                used.add(i);
            }

            return clusters.sort((a, b) => b.points.length - a.points.length);
        }

        function analyzeTrend(historicalData) {
            const recentData = historicalData.slice(-30); // Last 30 days
            const olderData = historicalData.slice(-60, -30); // Previous 30 days
            
            const recentAvg = recentData.reduce((sum, d) => sum + d.close, 0) / recentData.length;
            const olderAvg = olderData.reduce((sum, d) => sum + d.close, 0) / olderData.length;
            
            const trendChange = ((recentAvg - olderAvg) / olderAvg) * 100;
            
            let currentTrend = 'sideways';
            let trendStrength = 50;
            
            if (trendChange > 2) {
                currentTrend = 'uptrend';
                trendStrength = Math.min(75 + (trendChange * 2), 95);
            } else if (trendChange < -2) {
                currentTrend = 'downtrend';
                trendStrength = Math.min(75 + (Math.abs(trendChange) * 2), 95);
            } else {
                trendStrength = 60 - Math.abs(trendChange * 5);
            }

            // Calculate volatility
            const prices = recentData.map(d => d.close);
            const volatility = calculateVolatility(prices);
            
            return {
                currentTrend,
                trendStrength: Math.round(trendStrength),
                trendChange: +trendChange.toFixed(2),
                volatility: +volatility.toFixed(2),
                avgVolume: Math.round(recentData.reduce((sum, d) => sum + d.volume, 0) / recentData.length)
            };
        }

        function calculateVolatility(prices) {
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
                returns.push((prices[i] - prices[i-1]) / prices[i-1]);
            }
            
            const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
            
            return Math.sqrt(variance) * Math.sqrt(252) * 100; // Annualized volatility as percentage
        }

        function getStrategyAnalysis(currentData, levels, trendAnalysis, strategy) {
            const analysis = {
                signals: [],
                recommendation: 'WAIT',
                riskLevel: 'Medium'
            };

            const currentPrice = currentData.currentPrice;
            const nearestSupport = levels.currentSupport;
            const nearestResistance = levels.currentResistance;

            switch (strategy) {
                case 'range':
                    if (nearestSupport && currentPrice <= nearestSupport.price * 1.03) {
                        analysis.signals.push(`Near REAL support at $${nearestSupport.price} (tested ${nearestSupport.touches} times)`);
                        analysis.recommendation = 'BUY';
                        analysis.riskLevel = nearestSupport.strength === 'Strong' ? 'Low' : 'Medium';
                    } else if (nearestResistance && currentPrice >= nearestResistance.price * 0.97) {
                        analysis.signals.push(`Near REAL resistance at $${nearestResistance.price} (tested ${nearestResistance.touches} times)`);
                        analysis.recommendation = 'SELL';
                        analysis.riskLevel = nearestResistance.strength === 'Strong' ? 'Low' : 'Medium';
                    } else {
                        analysis.signals.push('Price in middle of range - wait for better setup');
                        analysis.riskLevel = 'High';
                    }
                    break;

                case 'breakout':
                    if (nearestResistance && currentPrice > nearestResistance.price) {
                        analysis.signals.push(`BREAKOUT above $${nearestResistance.price} resistance (${nearestResistance.touches} touches)`);
                        analysis.recommendation = 'BUY';
                        analysis.riskLevel = 'Medium';
                    } else if (nearestSupport && currentPrice < nearestSupport.price) {
                        analysis.signals.push(`BREAKDOWN below $${nearestSupport.price} support (${nearestSupport.touches} touches)`);
                        analysis.recommendation = 'SELL';
                        analysis.riskLevel = 'Medium';
                    }
                    break;

                case 'trend':
                    if (trendAnalysis.currentTrend === 'uptrend' && trendAnalysis.trendStrength > 70) {
                        analysis.signals.push(`Strong ${trendAnalysis.currentTrend} with ${trendAnalysis.trendStrength}% confidence`);
                        analysis.recommendation = 'BUY on dips';
                        analysis.riskLevel = 'Low';
                    } else if (trendAnalysis.currentTrend === 'downtrend' && trendAnalysis.trendStrength > 70) {
                        analysis.signals.push(`Strong ${trendAnalysis.currentTrend} with ${trendAnalysis.trendStrength}% confidence`);
                        analysis.recommendation = 'SELL on bounces';
                        analysis.riskLevel = 'Low';
                    }
                    break;

                case 'reversal':
                    if (trendAnalysis.volatility > 30 && Math.abs(currentData.changePercent) > 3) {
                        const direction = currentData.change < 0 ? 'UP' : 'DOWN';
                        analysis.signals.push(`High volatility (${trendAnalysis.volatility}%) + ${Math.abs(currentData.changePercent)}% move = potential reversal ${direction}`);
                        analysis.recommendation = direction === 'UP' ? 'BUY reversal' : 'SELL reversal';
                        analysis.riskLevel = 'High';
                    }
                    break;
            }

            return analysis;
        }

        // ====== SIMPLE EXPLANATION FUNCTIONS ======
        function showSimpleExplanation(stockIndex) {
            const stock = trackedStocks[stockIndex];
            const explanation = generateSimpleExplanation(stock);
            
            document.getElementById('explanationText').innerHTML = explanation;
            document.getElementById('explanationModal').style.display = 'block';
        }

        function closeExplanation() {
            document.getElementById('explanationModal').style.display = 'none';
        }

        function generateSimpleExplanation(stock) {
            const data = stock.data;
            const analysis = stock.analysis;
            const levels = analysis.levels;
            const trend = analysis.historicalAnalysis;

            let explanation = `
                <h3>üîç What's Happening with ${data.symbol}?</h3>
                <p>Let me break down the analysis in simple terms...</p>
            `;

            // Current situation
            explanation += `
                <div class="key-point">
                    <strong>üìç Current Situation:</strong><br>
                    ${data.symbol} is trading at <strong>$${data.currentPrice}</strong>, which is 
                    ${data.change >= 0 ? 'up' : 'down'} <strong>${Math.abs(data.changePercent)}%</strong> today.
                </div>
            `;

            // Support and Resistance explanation
            if (levels.currentSupport || levels.currentResistance) {
                explanation += `<h3>üí™ Support and Resistance - Think of These as Price "Magnets"</h3>`;
                
                if (levels.currentSupport) {
                    const supportDistance = ((data.currentPrice - levels.currentSupport.price) / levels.currentSupport.price * 100).toFixed(1);
                    explanation += `
                        <div class="analogy">
                            <strong>üõ°Ô∏è Support at $${levels.currentSupport.price}:</strong><br>
                            Think of this like a strong safety net. In the past ${levels.currentSupport.touches} times, when the stock price fell to around $${levels.currentSupport.price}, buyers stepped in and pushed it back up. It's like a floor that's hard to break through.<br><br>
                            <strong>Right now:</strong> The stock is ${supportDistance}% above this support level.
                            ${supportDistance < 3 ? ' <strong>This is very close!</strong> üéØ' : ''}
                        </div>
                    `;
                }

                if (levels.currentResistance) {
                    const resistanceDistance = ((levels.currentResistance.price - data.currentPrice) / data.currentPrice * 100).toFixed(1);
                    explanation += `
                        <div class="analogy">
                            <strong>üöß Resistance at $${levels.currentResistance.price}:</strong><br>
                            This is like a ceiling. ${levels.currentResistance.touches} times before, when the stock tried to go above $${levels.currentResistance.price}, sellers came in and pushed it back down. Think of it as a price level where people think "this is expensive, I'll sell."<br><br>
                            <strong>Right now:</strong> The stock is ${resistanceDistance}% below this resistance level.
                            ${resistanceDistance < 3 ? ' <strong>This is very close!</strong> üéØ' : ''}
                        </div>
                    `;
                }
            }

            // Strategy explanation
            explanation += `<h3>üìã Your ${analysis.strategy.toUpperCase()} Strategy Explained</h3>`;
            
            switch (analysis.strategy) {
                case 'range':
                    explanation += `
                        <div class="key-point">
                            <strong>Range Trading is like buying low and selling high in a predictable pattern:</strong><br>
                            ‚Ä¢ When the stock gets close to support (the "floor"), you consider buying<br>
                            ‚Ä¢ When it gets close to resistance (the "ceiling"), you consider selling<br>
                            ‚Ä¢ It's like buying apples when they're on sale and selling them when the price goes back up
                        </div>
                    `;
                    break;
                case 'breakout':
                    explanation += `
                        <div class="key-point">
                            <strong>Breakout Trading is like waiting for the dam to burst:</strong><br>
                            ‚Ä¢ You wait for the stock to break through a key level (support or resistance)<br>
                            ‚Ä¢ When it breaks through with force, you follow the direction<br>
                            ‚Ä¢ It's like waiting for a breakthrough moment and then jumping on board
                        </div>
                    `;
                    break;
                case 'trend':
                    explanation += `
                        <div class="key-point">
                            <strong>Trend Following is like riding the wave:</strong><br>
                            ‚Ä¢ If the stock is in a strong uptrend, you buy on dips<br>
                            ‚Ä¢ If it's in a strong downtrend, you avoid buying (or sell)<br>
                            ‚Ä¢ It's like going with the flow instead of fighting the current
                        </div>
                    `;
                    break;
                case 'reversal':
                    explanation += `
                        <div class="key-point">
                            <strong>Reversal Trading is like catching a bouncing ball:</strong><br>
                            ‚Ä¢ You look for signs that a trend is about to change direction<br>
                            ‚Ä¢ High volatility and big moves often signal potential reversals<br>
                            ‚Ä¢ It's riskier but can be very profitable if you're right
                        </div>
                    `;
                    break;
            }

            // Current recommendation explanation
            explanation += `<h3>üéØ Why the System Says "${analysis.recommendation}"</h3>`;
            
            if (analysis.recommendation === 'BUY') {
                explanation += `
                    <div class="action-item">
                        <strong>BUY Signal Explanation:</strong><br>
                        The system thinks this might be a good buying opportunity because:<br>
                        ${analysis.signals.map(signal => `‚Ä¢ ${signal}<br>`).join('')}
                        <br><strong>Think of it like:</strong> You're at a store and your favorite item just went on sale at a price you know is good based on past patterns.
                    </div>
                `;
            } else if (analysis.recommendation === 'SELL') {
                explanation += `
                    <div class="action-item">
                        <strong>SELL Signal Explanation:</strong><br>
                        The system thinks this might be a good selling opportunity because:<br>
                        ${analysis.signals.map(signal => `‚Ä¢ ${signal}<br>`).join('')}
                        <br><strong>Think of it like:</strong> You own something that just reached a price where many people have sold before.
                    </div>
                `;
            } else if (analysis.recommendation.includes('BREAKOUT')) {
                explanation += `
                    <div class="action-item">
                        <strong>Breakout Signal Explanation:</strong><br>
                        ${analysis.signals.map(signal => `‚Ä¢ ${signal}<br>`).join('')}
                        <br><strong>Think of it like:</strong> A dam just broke and water is rushing through - you want to go with the flow.
                    </div>
                `;
            } else {
                explanation += `
                    <div class="key-point">
                        <strong>WAIT Signal Explanation:</strong><br>
                        The system suggests waiting because the stock is not near any key decision points right now. 
                        It's like waiting for the right moment instead of forcing a trade.<br><br>
                        <strong>Why wait?</strong> Better opportunities usually come when the stock gets closer to support or resistance levels.
                    </div>
                `;
            }

            // Risk explanation
            explanation += `
                <h3>‚ö†Ô∏è Risk Level: ${analysis.riskLevel}</h3>
                <div class="key-point">
            `;
            
            if (analysis.riskLevel === 'Low') {
                explanation += `
                    <strong>Low Risk:</strong> This is like a "safer bet." The signals are strong and based on levels that have worked multiple times before. Think of it like buying from a store with a good return policy.
                `;
            } else if (analysis.riskLevel === 'Medium') {
                explanation += `
                    <strong>Medium Risk:</strong> This is a reasonable opportunity, but not as certain as a low-risk trade. It's like buying something that's probably a good deal, but you want to watch it closely.
                `;
            } else {
                explanation += `
                    <strong>High Risk:</strong> This is more speculative. Like trying to catch a falling knife or betting on a big change. Only consider if you're comfortable with potentially losing money.
                `;
            }
            
            explanation += `</div>`;

            // What to do next
            if (analysis.recommendation !== 'WAIT') {
                explanation += `
                    <h3>‚úÖ What Should You Actually Do?</h3>
                    <div class="action-item">
                        <strong>Step 1:</strong> Don't rush! This is just a signal, not a guarantee.<br>
                        <strong>Step 2:</strong> Look at the chart yourself to see if you agree.<br>
                        <strong>Step 3:</strong> If you decide to trade, use a stop loss at $${levels.stopLoss || 'TBD'}<br>
                        <strong>Step 4:</strong> Only risk money you can afford to lose (the tool suggests ${stock.riskPercent}% of your account).<br><br>
                        <strong>Remember:</strong> Even the best signals fail sometimes. That's why we use stop losses and position sizing!
                    </div>
                `;
            }

            // Mark Douglas wisdom
            explanation += `
                <h3>üß† Mark Douglas Wisdom for This Trade</h3>
                <div class="analogy">
                    <strong>"Think in probabilities, not certainties"</strong><br><br>
                    This analysis gives you an <em>edge</em> - a higher probability of success based on historical patterns. But remember:<br>
                    ‚Ä¢ Any individual trade can fail<br>
                    ‚Ä¢ Your job is to follow your rules consistently<br>
                    ‚Ä¢ Profits come from many trades, not just one<br>
                    ‚Ä¢ Accept the risk before you enter the trade<br><br>
                    <strong>The market doesn't owe you anything - but consistently following good setups over time can be profitable.</strong>
                </div>
            `;

            return explanation;
        }

        function displayStocks() {
            const container = document.getElementById('stocksContainer');
            if (trackedStocks.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">
                        <h3>No stocks being tracked yet</h3>
                        <p>Add a stock above to start tracking opportunities with real historical analysis</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = trackedStocks.map((stock, index) => {
                const data = stock.data;
                const analysis = stock.analysis;
                const levels = analysis.levels;

                return `
                    <div class="stock-card">
                        <div class="stock-header">
                            <button class="remove-btn" onclick="removeStock(${index})">Remove</button>
                            <div class="stock-symbol">${data.symbol}</div>
                            <div class="stock-price">$${data.currentPrice} 
                                <span style="font-size: 0.8em; opacity: 0.8;">
                                    (${data.change >= 0 ? '+' : ''}${data.change} / ${data.changePercent}%)
                                </span>
                            </div>
                            <div class="historical-info">
                                üìä Analyzed ${stock.historicalData?.length || 0} days of history ‚Ä¢ 
                                ${levels.supportLevels?.length || 0} support levels ‚Ä¢ 
                                ${levels.resistanceLevels?.length || 0} resistance levels
                            </div>
                            <a href="https://finviz.com/quote.ashx?t=${data.symbol}" target="_blank" class="chart-link">
                                üìä View Chart on Finviz
                            </a>
                        </div>
                        <div class="stock-body">
                            <div class="strategy-box">
                                <h5>üìã Strategy: ${analysis.strategy.toUpperCase()}</h5>
                                <strong>Recommendation: ${analysis.recommendation}</strong><br>
                                Risk Level: <span class="${analysis.riskLevel.toLowerCase()}">${analysis.riskLevel}</span><br>
                                Trend: ${analysis.historicalAnalysis?.currentTrend || 'Unknown'} 
                                (${analysis.historicalAnalysis?.trendStrength || 0}% confidence)
                                <br><br>
                                <button class="btn btn-secondary" onclick="showSimpleExplanation(${index})">
                                    üß† Explain Simply
                                </button>
                                <button class="btn" onclick="getAIAnalysis(${index})" style="margin-left: 10px;">
                                    ü§ñ AI Analysis
                                </button>
                            </div>

                            ${generateAlerts(stock)}

                            <div class="analysis-section">
                                <h4>üìä Historical Analysis Signals</h4>
                                ${analysis.signals.map(signal => 
                                    `<div class="analysis-item">${signal}</div>`
                                ).join('')}
                            </div>

                            <div class="analysis-section">
                                <h4>üéØ REAL Support & Resistance Levels</h4>
                                ${levels.currentSupport ? 
                                    `<div class="analysis-item strong">üí™ Current Support: $${levels.currentSupport.price} 
                                    (${levels.currentSupport.touches} touches, ${levels.currentSupport.strength})</div>` : ''}
                                ${levels.currentResistance ? 
                                    `<div class="analysis-item strong">üí™ Current Resistance: $${levels.currentResistance.price} 
                                    (${levels.currentResistance.touches} touches, ${levels.currentResistance.strength})</div>` : ''}
                                
                                ${levels.supportLevels?.slice(0, 3).map(level => 
                                    `<div class="analysis-item">Support: $${level.price} (${level.touches} touches, ${level.strength})</div>`
                                ).join('') || ''}
                                
                                ${levels.resistanceLevels?.slice(0, 3).map(level => 
                                    `<div class="analysis-item warning">Resistance: $${level.price} (${level.touches} touches, ${level.strength})</div>`
                                ).join('') || ''}
                                
                                ${levels.stopLoss ? `<div class="analysis-item danger">üìç Suggested Stop Loss: $${levels.stopLoss}</div>` : ''}
                                ${levels.takeProfit ? `<div class="analysis-item">üéØ Suggested Take Profit: $${levels.takeProfit}</div>` : ''}
                            </div>

                            <div class="douglas-principles">
                                <h5>üß† Mark Douglas Principles</h5>
                                <strong>Edge:</strong> ${analysis.douglasPrinciples.edge}<br>
                                <strong>Probability:</strong> ${analysis.douglasPrinciples.probability}<br>
                                <strong>Risk:</strong> ${analysis.douglasPrinciples.riskAcceptance}<br>
                                <strong>Execution:</strong> ${analysis.douglasPrinciples.execution}
                            </div>

                            <div class="last-updated">
                                Last updated: ${new Date(stock.lastUpdated).toLocaleString()}
                                <button class="btn" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;" 
                                        onclick="updateStock(${index})">üîÑ Update</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function generateAlerts(stock) {
            const data = stock.data;
            const levels = stock.analysis.levels;
            const alerts = [];

            // Check proximity to support/resistance
            if (levels.currentSupport && Math.abs(data.currentPrice - levels.currentSupport.price) / levels.currentSupport.price < 0.02) {
                alerts.push({
                    type: 'success',
                    message: `üéØ Near ${levels.currentSupport.strength} Support: $${levels.currentSupport.price}`,
                    action: `Potential BUY opportunity (tested ${levels.currentSupport.touches} times)`
                });
            }

            if (levels.currentResistance && Math.abs(data.currentPrice - levels.currentResistance.price) / levels.currentResistance.price < 0.02) {
                alerts.push({
                    type: 'warning',
                    message: `‚ö†Ô∏è Near ${levels.currentResistance.strength} Resistance: $${levels.currentResistance.price}`,
                    action: `Watch for rejection (tested ${levels.currentResistance.touches} times)`
                });
            }

            // Check for breakouts
            if (levels.currentResistance && data.currentPrice > levels.currentResistance.price) {
                alerts.push({
                    type: 'success',
                    message: `üöÄ BREAKOUT above $${levels.currentResistance.price} resistance!`,
                    action: 'Consider buy on pullback confirmation'
                });
            }

            if (levels.currentSupport && data.currentPrice < levels.currentSupport.price) {
                alerts.push({
                    type: 'danger',
                    message: `üìâ BREAKDOWN below $${levels.currentSupport.price} support!`,
                    action: 'Consider exit or short position'
                });
            }

            if (alerts.length === 0) {
                return '<div class="alert info">‚úÖ No immediate action - price between key levels</div>';
            }

            return alerts.map(alert => `
                <div class="alert ${alert.type}">
                    ${alert.message}<br>
                    <strong>Action:</strong> ${alert.action}
                </div>
            `).join('');
        }

        async function updateStock(index) {
            try {
                const stock = trackedStocks[index];
                const newCurrentData = await fetchCurrentStockData(stock.symbol);
                const newAnalysis = analyzeStockWithHistory(newCurrentData, stock.historicalData, stock.strategy);
                
                trackedStocks[index] = {
                    ...stock,
                    data: newCurrentData,
                    analysis: newAnalysis,
                    lastUpdated: new Date().toISOString()
                };
                saveTrackedStocks();
                displayStocks();
            } catch (error) {
                alert('Error updating stock: ' + error.message);
            }
        }

        function removeStock(index) {
            if (confirm('Are you sure you want to remove this stock from tracking?')) {
                trackedStocks.splice(index, 1);
                saveTrackedStocks();
                displayStocks();
            }
        }

        async function checkAllStocksForAlerts() {
            for (let i = 0; i < trackedStocks.length; i++) {
                await updateStock(i);
            }
        }

        // Close explanation modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('explanationModal');
            if (event.target === modal) {
                closeExplanation();
            }
        }

        // ====== CLAUDE API INTEGRATION ======
        function saveApiKey() {
            const apiKey = document.getElementById('claudeApiKey').value.trim();
            const statusElement = document.getElementById('apiKeyStatus');
            
            if (!apiKey || !apiKey.startsWith('sk-ant-api03-')) {
                statusElement.innerHTML = '<span style="color: red;">‚ùå Invalid API Key</span>';
                return;
            }
            
            localStorage.setItem('claudeApiKey', apiKey);
            statusElement.innerHTML = '<span style="color: green;">‚úÖ API Key Saved</span>';
            document.getElementById('claudeApiKey').value = '';
            setTimeout(() => {
                statusElement.innerHTML = '';
            }, 3000);
        }

        function saveProxyUrl() {
            const proxyUrl = document.getElementById('proxyUrl').value.trim();
            const statusElement = document.getElementById('proxyStatus');
            
            if (!proxyUrl || !proxyUrl.startsWith('https://')) {
                statusElement.innerHTML = '<span style="color: red;">‚ùå Invalid URL</span>';
                return;
            }
            
            localStorage.setItem('proxyUrl', proxyUrl);
            statusElement.innerHTML = '<span style="color: green;">‚úÖ Proxy URL Saved</span>';
            document.getElementById('proxyUrl').value = '';
            setTimeout(() => {
                statusElement.innerHTML = '';
            }, 3000);
        }

        function loadApiKey() {
            const stored = localStorage.getItem('claudeApiKey');
            if (stored) {
                document.getElementById('apiKeyStatus').innerHTML = '<span style="color: green;">‚úÖ API Key Ready</span>';
            }
            return stored;
        }

        function loadProxyUrl() {
            const stored = localStorage.getItem('proxyUrl');
            if (stored) {
                document.getElementById('proxyStatus').innerHTML = '<span style="color: green;">‚úÖ Proxy Ready</span>';
            }
            return stored;
        }

        async function getAIAnalysis(stockIndex) {
            const apiKey = localStorage.getItem('claudeApiKey');
            const proxyUrl = localStorage.getItem('proxyUrl');
            
            if (!apiKey) {
                alert('Please enter and save your Claude API key first.');
                return;
            }
            
            if (!proxyUrl) {
                alert('Please enter and save your proxy URL first. Deploy the proxy function to Vercel and enter the URL.');
                return;
            }

            const stock = trackedStocks[stockIndex];
            const analysisButton = event.target;
            const originalText = analysisButton.innerHTML;
            
            try {
                analysisButton.innerHTML = 'ü§ñ Analyzing...';
                analysisButton.disabled = true;
                
                const aiAnalysis = await callClaudeAPI(stock, apiKey, proxyUrl);
                showAIAnalysis(stock.data.symbol, aiAnalysis);
                
            } catch (error) {
                console.error('AI Analysis Error:', error);
                alert('Error getting AI analysis: ' + error.message);
            } finally {
                analysisButton.innerHTML = originalText;
                analysisButton.disabled = false;
            }
        }

        async function callClaudeAPI(stock, apiKey, proxyUrl) {
            const prompt = buildTradingAnalysisPrompt(stock);
            
            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    type: 'claude',
                    apiKey: apiKey,
                    prompt: prompt
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Proxy Error: ${errorData.error || response.statusText}`);
            }

            const data = await response.json();
            return data.analysis;
        }

        function buildTradingAnalysisPrompt(stock) {
            const data = stock.data;
            const analysis = stock.analysis;
            const levels = analysis.levels;
            const trend = analysis.historicalAnalysis;
            const historical = stock.historicalData;

            return `You are an expert stock trader and analyst. Please provide a comprehensive, actionable trading analysis for ${data.symbol} based on the following complete dataset. I want your professional opinion synthesizing ALL this information into clear guidance for a retail trader.

CURRENT MARKET DATA:
- Symbol: ${data.symbol}
- Current Price: ${data.currentPrice}
- Today's Change: ${data.change >= 0 ? '+' : ''}${data.change} (${data.changePercent}%)
- Open: ${data.open}, High: ${data.high}, Low: ${data.low}
- Volume: ${data.volume.toLocaleString()}
- Previous Close: ${data.previousClose}

HISTORICAL ANALYSIS (${historical.length} days of data):
- Current Trend: ${trend.currentTrend} with ${trend.trendStrength}% confidence
- Trend Change: ${trend.trendChange}% (comparing recent 30 days vs previous 30 days)
- Volatility: ${trend.volatility}% (annualized)
- Average Volume: ${trend.avgVolume.toLocaleString()}

SUPPORT & RESISTANCE LEVELS (from 6-month analysis):
Support Levels:
${levels.supportLevels?.map(level => `- ${level.price} (${level.touches} touches, ${level.strength} strength)`).join('\n') || 'None identified'}

Resistance Levels:
${levels.resistanceLevels?.map(level => `- ${level.price} (${level.touches} touches, ${level.strength} strength)`).join('\n') || 'None identified'}

Current Nearest Support: ${levels.currentSupport ? `${levels.currentSupport.price} (${levels.currentSupport.touches} touches, ${levels.currentSupport.strength})` : 'None'}
Current Nearest Resistance: ${levels.currentResistance ? `${levels.currentResistance.price} (${levels.currentResistance.touches} touches, ${levels.currentResistance.strength})` : 'None'}

TRADING STRATEGY: ${analysis.strategy}
CURRENT SYSTEM RECOMMENDATION: ${analysis.recommendation}
CURRENT SIGNALS: ${analysis.signals.join(', ')}
RISK LEVEL: ${analysis.riskLevel}
SUGGESTED STOP LOSS: ${levels.stopLoss ? `${levels.stopLoss}` : 'TBD'}

TRADER'S RISK TOLERANCE: ${stock.riskPercent}% per trade

Please provide:
1. Your professional assessment of this trading opportunity
2. Whether you agree/disagree with the system's recommendation and why
3. Specific entry, exit, and stop-loss recommendations with reasoning
4. Risk assessment and position sizing advice
5. What to watch for next (key price levels, volume patterns, time factors)
6. Any market context or external factors I should consider

Write this in a clear, actionable format that a retail trader can immediately understand and act upon. Be specific with price levels and reasoning. If you see any red flags or better opportunities, mention them.`;
        }

        function showAIAnalysis(symbol, analysis) {
            const existingModal = document.getElementById('aiAnalysisModal');
            if (existingModal) {
                existingModal.remove();
            }

            const modal = document.createElement('div');
            modal.id = 'aiAnalysisModal';
            modal.className = 'explanation-modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="explanation-content">
                    <div class="explanation-header" style="background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);">
                        <span class="close-explanation" onclick="closeAIAnalysis()">&times;</span>
                        <h2>ü§ñ AI Trading Analysis: ${symbol}</h2>
                        <p style="margin: 10px 0 0 0; opacity: 0.9;">Professional analysis by Claude</p>
                    </div>
                    <div class="simple-explanation" style="white-space: pre-wrap; font-family: 'Segoe UI', sans-serif; line-height: 1.6;">
                        ${analysis}
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; font-size: 0.9em; color: #666;">
                        <strong>üí° Note:</strong> This analysis cost approximately $0.02 and is based on current data. Always do your own research and never risk more than you can afford to lose.
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.onclick = function(event) {
                if (event.target === modal) {
                    closeAIAnalysis();
                }
            }
        }

        function closeAIAnalysis() {
            const modal = document.getElementById('aiAnalysisModal');
            if (modal) {
                modal.remove();
            }
        }

        // Load API key status on page load
        window.addEventListener('load', function() {
            loadApiKey();
            loadProxyUrl();
        });

        // Allow Enter key to add stock
        document.addEventListener('DOMContentLoaded', function() {
            const stockInput = document.getElementById('stockSymbol');
            if (stockInput) {
                stockInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') addStock();
                });
            }
        });
    </script>
</body>
</html>
