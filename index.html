<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Stock Trading Tracker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .main-content {
            padding: 30px;
        }
        .add-stock-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }
        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .input-group input, .input-group select {
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-width: 150px;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }
        .btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }
        .btn-danger:hover {
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        }
        .stocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .stock-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }
        .stock-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        .stock-header {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            padding: 20px;
            position: relative;
        }
        .stock-symbol {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stock-price {
            font-size: 1.3rem;
            opacity: 0.9;
        }
        .stock-body {
            padding: 20px;
        }
        .analysis-section {
            margin-bottom: 20px;
        }
        .analysis-section h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .analysis-item {
            background: #f8f9fa;
            padding: 10px 15px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        .analysis-item.warning {
            border-left-color: #ff9800;
            background: #fff3e0;
        }
        .analysis-item.danger {
            border-left-color: #f44336;
            background: #ffebee;
        }
        .analysis-item.strong {
            border-left-color: #2e7d32;
            background: #e8f5e8;
            font-weight: bold;
        }
        .analysis-item.trendline {
            border-left-color: #673ab7;
            background: #f3e5f5;
        }
        .analysis-item.trendline-break {
            border-left-color: #e91e63;
            background: #fce4ec;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        .alert {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        .alert.success {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
        }
        .alert.info {
            background: linear-gradient(135deg, #2196F3 0%, #1565C0 100%);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .chart-link {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 15px;
            border-radius: 6px;
            text-decoration: none;
            margin: 10px 0;
            font-weight: 500;
        }
        .chart-link:hover {
            background: #bbdefb;
        }
        .remove-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .error {
            background: #ffcdd2;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .douglas-principles {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #4CAF50;
        }
        .douglas-principles h5 {
            color: #2e7d32;
            margin-bottom: 8px;
        }
        .last-updated {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 15px;
        }
        .strategy-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #ffcc02;
        }
        .strategy-box h5 {
            color: #ef6c00;
            margin-bottom: 10px;
        }
        .historical-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #1565c0;
        }
        .trendline-info {
            background: #f3e5f5;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #673ab7;
        }
        .api-status {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #2e7d32;
        }
        @media (max-width: 768px) {
            .stocks-grid {
                grid-template-columns: 1fr;
            }
            .input-group {
                flex-direction: column;
            }
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìà Smart Stock Trading Tracker</h1>
            <p>Track opportunities using Mark Douglas trading principles</p>
            <div style="font-size: 0.9rem; margin-top: 15px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;">
                üì° <strong>Real API Keys Active:</strong> Using your Twelve Data (800 calls/day) and Polygon.io (5 calls/min) keys for real-time stock data and complete historical analysis with trendlines.
            </div>
        </div>
        <div class="main-content">
            <div class="add-stock-section">
                <h3>Add Stock to Track</h3>
                <div class="input-group">
                    <input type="text" id="stockSymbol" placeholder="Stock Symbol (e.g., AAPL)" maxlength="10">
                    <select id="strategy">
                        <option value="range">Range Trading (Buy Support/Sell Resistance)</option>
                        <option value="breakout">Breakout Trading</option>
                        <option value="trend">Trend Following</option>
                        <option value="reversal">Reversal Trading</option>
                    </select>
                    <input type="number" id="riskPercent" placeholder="Risk % (1-5)" min="0.5" max="10" step="0.5" value="2">
                    <button class="btn" onclick="addStock()">Add Stock</button>
                </div>
                <div id="addStockError"></div>
            </div>
            <div id="stocksContainer" class="stocks-grid">
                <!-- Stocks will be added here -->
            </div>
        </div>
    </div>
    <script>
        // ====== CORS-FRIENDLY STOCK TRACKER SCRIPT ======
        let trackedStocks = [];
        
        // Using your real API keys for much better data access
        const TWELVE_DATA_KEY = '82bc8937fd9d488195cbed42be934f10';
        const POLYGON_API_KEY = 'dluOx2rSNYsAw7plr3E4monBjOLlc70l';

        window.onload = function() {
            loadTrackedStocks();
            displayStocks();
            setInterval(checkAllStocksForAlerts, 3600000);
        };

        function loadTrackedStocks() {
            const stored = localStorage.getItem('trackedStocks');
            if (stored) trackedStocks = JSON.parse(stored);
        }

        function saveTrackedStocks() {
            localStorage.setItem('trackedStocks', JSON.stringify(trackedStocks));
        }

        async function addStock() {
            const symbol = document.getElementById('stockSymbol').value.toUpperCase().trim();
            const strategy = document.getElementById('strategy').value;
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
            const errorDiv = document.getElementById('addStockError');
            errorDiv.innerHTML = '';

            if (!symbol) {
                errorDiv.innerHTML = '<div class="error">Please enter a stock symbol</div>';
                return;
            }
            if (trackedStocks.find(s => s.symbol === symbol)) {
                errorDiv.innerHTML = '<div class="error">This stock is already being tracked</div>';
                return;
            }
            try {
                errorDiv.innerHTML = '<div class="loading">Fetching real-time data with your API keys and analyzing 6 months of history + trendlines...</div>';
                
                // Get both current and historical data using CORS-friendly APIs
                const [currentData, historicalData] = await Promise.all([
                    fetchCurrentDataCORSFriendly(symbol),
                    fetchHistoricalDataCORSFriendly(symbol)
                ]);
                
                if (!currentData) throw new Error('Unable to fetch current stock data');
                if (!historicalData || historicalData.length < 30) throw new Error('Unable to fetch sufficient historical data');
                
                const analysis = analyzeStockWithHistoryAndTrendlines(currentData, historicalData, strategy);
                const newStock = {
                    symbol: symbol,
                    strategy: strategy,
                    riskPercent: riskPercent,
                    data: currentData,
                    historicalData: historicalData,
                    analysis: analysis,
                    alerts: [],
                    dateAdded: new Date().toISOString(),
                    lastUpdated: new Date().toISOString()
                };
                trackedStocks.push(newStock);
                saveTrackedStocks();
                displayStocks();
                document.getElementById('stockSymbol').value = '';
                errorDiv.innerHTML = '';
            } catch (error) {
                errorDiv.innerHTML = `<div class="error">Error adding stock: ${error.message}</div>`;
            }
        }

        async function fetchCurrentDataCORSFriendly(symbol) {
            // Try multiple CORS-friendly sources
            const dataSources = [
                { name: 'Twelve Data', func: () => fetchFromTwelveData(symbol) },
                { name: 'Polygon Free', func: () => fetchFromPolygonFree(symbol) },
                { name: 'Fallback Demo', func: () => createDemoData(symbol) }
            ];
            
            for (const source of dataSources) {
                try {
                    const data = await source.func();
                    if (data && data.currentPrice && data.currentPrice > 0) {
                        console.log(`‚úÖ Successfully fetched ${symbol} from ${source.name}`);
                        return data;
                    }
                } catch (error) {
                    console.log(`‚ùå ${source.name} failed: ${error.message}`);
                }
            }
            throw new Error('Unable to fetch current stock data with your API keys - all sources failed');
        }

        async function fetchHistoricalDataCORSFriendly(symbol, months = 6) {
            try {
                console.log(`üìä Fetching ${months} months of historical data for ${symbol} from Twelve Data...`);
                return await fetchHistoricalFromTwelveData(symbol, months);
            } catch (error) {
                console.log('‚ùå Twelve Data historical failed:', error.message);
                console.log('üîÑ Falling back to demo data for demonstration...');
                // Fallback to demo data for demonstration
                return generateDemoHistoricalData(symbol, months);
            }
        }

        async function fetchFromTwelveData(symbol) {
            // Twelve Data has a free tier that supports CORS
            const url = `https://api.twelvedata.com/quote?symbol=${symbol}&apikey=${TWELVE_DATA_KEY}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Twelve Data API failed');
                
                const data = await response.json();
                if (data.code) {
                    if (data.code === 429) {
                        throw new Error('Daily API limit reached (800 calls/day). Try again tomorrow or upgrade plan.');
                    }
                    throw new Error(data.message || 'Twelve Data API error');
                }
                
                const currentPrice = parseFloat(data.close);
                const previousClose = parseFloat(data.previous_close);
                
                return {
                    symbol: symbol,
                    currentPrice: +currentPrice.toFixed(2),
                    open: +parseFloat(data.open).toFixed(2),
                    high: +parseFloat(data.high).toFixed(2),
                    low: +parseFloat(data.low).toFixed(2),
                    volume: parseInt(data.volume),
                    change: +(currentPrice - previousClose).toFixed(2),
                    changePercent: +(((currentPrice - previousClose) / previousClose) * 100).toFixed(2),
                    previousClose: +previousClose.toFixed(2)
                };
            } catch (error) {
                throw new Error('Twelve Data fetch failed: ' + error.message);
            }
        }

        async function fetchFromPolygonFree(symbol) {
            // Polygon has a free tier but limited
            const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/prev?adjusted=true&apikey=${POLYGON_API_KEY}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Polygon API failed');
                
                const data = await response.json();
                if (data.status === 'ERROR') {
                    throw new Error(data.error || 'Polygon API error');
                }
                if (!data.results || data.results.length === 0) {
                    throw new Error('No data available for this symbol from Polygon');
                }
                
                const result = data.results[0];
                const currentPrice = result.c;
                const previousClose = result.o;
                
                return {
                    symbol: symbol,
                    currentPrice: +currentPrice.toFixed(2),
                    open: +result.o.toFixed(2),
                    high: +result.h.toFixed(2),
                    low: +result.l.toFixed(2),
                    volume: result.v,
                    change: +(currentPrice - previousClose).toFixed(2),
                    changePercent: +(((currentPrice - previousClose) / previousClose) * 100).toFixed(2),
                    previousClose: +previousClose.toFixed(2)
                };
            } catch (error) {
                throw new Error('Polygon fetch failed: ' + error.message);
            }
        }

        async function fetchHistoricalFromTwelveData(symbol, months = 6) {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setMonth(endDate.getMonth() - months);
            
            const url = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=1day&start_date=${startDate.toISOString().split('T')[0]}&end_date=${endDate.toISOString().split('T')[0]}&apikey=${TWELVE_DATA_KEY}`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error('Twelve Data historical API failed');
            
            const data = await response.json();
            if (data.code) {
                if (data.code === 429) {
                    throw new Error('Daily limit reached (800 calls/day). Historical data fallback to demo.');
                }
                throw new Error(data.message || 'Historical API error');
            }
            
            const timeSeries = data.values;
            if (!timeSeries) throw new Error('No historical data from Twelve Data');
            
            const historicalData = [];
            
            for (let i = 0; i < timeSeries.length; i++) {
                const dayData = timeSeries[i];
                historicalData.push({
                    date: dayData.datetime,
                    timestamp: new Date(dayData.datetime).getTime() / 1000,
                    index: i,
                    open: +parseFloat(dayData.open).toFixed(2),
                    high: +parseFloat(dayData.high).toFixed(2),
                    low: +parseFloat(dayData.low).toFixed(2),
                    close: +parseFloat(dayData.close).toFixed(2),
                    volume: parseInt(dayData.volume) || 1000000
                });
            }
            
            return historicalData.reverse(); // Chronological order
        }

        function createDemoData(symbol) {
            // Generate realistic demo data for demonstration
            const basePrice = Math.random() * 200 + 50; // Random price between 50-250
            const change = (Math.random() - 0.5) * basePrice * 0.05; // ¬±5% change
            
            return {
                symbol: symbol,
                currentPrice: +(basePrice + change).toFixed(2),
                open: +basePrice.toFixed(2),
                high: +(basePrice + Math.abs(change) * 1.2).toFixed(2),
                low: +(basePrice - Math.abs(change) * 1.2).toFixed(2),
                volume: Math.floor(Math.random() * 10000000) + 1000000,
                change: +change.toFixed(2),
                changePercent: +((change / basePrice) * 100).toFixed(2),
                previousClose: +basePrice.toFixed(2)
            };
        }

        function generateDemoHistoricalData(symbol, months = 6) {
            const historicalData = [];
            const days = months * 30;
            let price = Math.random() * 200 + 50;
            
            for (let i = 0; i < days; i++) {
                const date = new Date();
                date.setDate(date.getDate() - (days - i));
                
                // Add some realistic price movement
                const change = (Math.random() - 0.5) * price * 0.03;
                price += change;
                price = Math.max(price, 10); // Minimum price
                
                const dayHigh = price * (1 + Math.random() * 0.02);
                const dayLow = price * (1 - Math.random() * 0.02);
                
                historicalData.push({
                    date: date.toISOString().split('T')[0],
                    timestamp: date.getTime() / 1000,
                    index: i,
                    open: +price.toFixed(2),
                    high: +dayHigh.toFixed(2),
                    low: +dayLow.toFixed(2),
                    close: +price.toFixed(2),
                    volume: Math.floor(Math.random() * 5000000) + 1000000
                });
            }
            
            return historicalData;
        }

        // Include all the analysis functions from the previous version
        function analyzeStockWithHistoryAndTrendlines(currentData, historicalData, strategy) {
            const analysis = {
                strategy: strategy,
                signals: [],
                levels: {},
                trendlines: {},
                douglasPrinciples: {},
                recommendation: '',
                riskLevel: 'Medium',
                historicalAnalysis: {}
            };

            // Calculate horizontal support and resistance from historical data
            const supportResistanceLevels = findSupportResistanceLevels(historicalData);
            analysis.levels = supportResistanceLevels;
            
            // Find trendlines
            const trendlineAnalysis = findTrendlines(historicalData);
            analysis.trendlines = trendlineAnalysis;
            
            // Analyze overall trend and patterns
            const trendAnalysis = analyzeTrend(historicalData);
            analysis.historicalAnalysis = trendAnalysis;
            
            // Get specific strategy analysis incorporating trendlines
            const strategyAnalysis = getStrategyAnalysisWithTrendlines(currentData, analysis.levels, analysis.trendlines, trendAnalysis, strategy);
            Object.assign(analysis, strategyAnalysis);
            
            // Douglas principles
            analysis.douglasPrinciples = {
                edge: `${strategy} strategy: ${analysis.levels.supportLevels.length} support, ${analysis.levels.resistanceLevels.length} resistance, ${analysis.trendlines.ascending.length} ascending & ${analysis.trendlines.descending.length} descending trendlines`,
                probability: `Historical data: ${analysis.historicalAnalysis.trendStrength}% confidence in ${analysis.historicalAnalysis.currentTrend} trend`,
                riskAcceptance: `Stop loss at nearest major level or trendline break: $${analysis.levels.stopLoss || analysis.trendlines.stopLoss || 'TBD'}`,
                execution: `Entry signals from ${analysis.trendlines.activeTrendlines} active trendlines + horizontal levels`
            };

            return analysis;
        }

        function findTrendlines(historicalData) {
            const trendlines = {
                ascending: [],
                descending: [],
                activeTrendlines: 0,
                nearestAscending: null,
                nearestDescending: null,
                currentTrendlineLevel: null,
                trendlineBreaks: [],
                stopLoss: null
            };

            // Get swing points
            const swingPoints = findSwingPoints(historicalData);
            
            // Find ascending trendlines (connecting swing lows)
            trendlines.ascending = findAscendingTrendlines(swingPoints.lows, historicalData);
            
            // Find descending trendlines (connecting swing highs)  
            trendlines.descending = findDescendingTrendlines(swingPoints.highs, historicalData);
            
            // Find currently active trendlines
            const currentPrice = historicalData[historicalData.length - 1].close;
            const currentIndex = historicalData.length - 1;
            
            // Check which trendlines are currently relevant
            trendlines.ascending.forEach(trendline => {
                const currentTrendlinePrice = calculateTrendlinePrice(trendline, currentIndex);
                if (Math.abs(currentPrice - currentTrendlinePrice) / currentPrice < 0.05) { // Within 5%
                    trendlines.activeTrendlines++;
                    if (!trendlines.nearestAscending || currentTrendlinePrice > trendlines.nearestAscending.currentPrice) {
                        trendlines.nearestAscending = {
                            ...trendline,
                            currentPrice: currentTrendlinePrice
                        };
                    }
                }
            });
            
            trendlines.descending.forEach(trendline => {
                const currentTrendlinePrice = calculateTrendlinePrice(trendline, currentIndex);
                if (Math.abs(currentPrice - currentTrendlinePrice) / currentPrice < 0.05) { // Within 5%
                    trendlines.activeTrendlines++;
                    if (!trendlines.nearestDescending || currentTrendlinePrice < trendlines.nearestDescending.currentPrice) {
                        trendlines.nearestDescending = {
                            ...trendline,
                            currentPrice: currentTrendlinePrice
                        };
                    }
                }
            });
            
            // Check for trendline breaks
            trendlines.trendlineBreaks = detectTrendlineBreaks(trendlines, historicalData);
            
            // Set stop loss based on trendlines
            if (trendlines.nearestAscending) {
                trendlines.stopLoss = +(trendlines.nearestAscending.currentPrice * 0.97).toFixed(2);
            } else if (trendlines.nearestDescending) {
                trendlines.stopLoss = +(trendlines.nearestDescending.currentPrice * 1.03).toFixed(2);
            }

            return trendlines;
        }

        function findAscendingTrendlines(lows, historicalData) {
            const trendlines = [];
            const minTouches = 2;
            const maxAngle = 45; // Maximum angle in degrees
            
            for (let i = 0; i < lows.length - 1; i++) {
                for (let j = i + 1; j < lows.length; j++) {
                    const point1 = lows[i];
                    const point2 = lows[j];
                    
                    // Calculate slope (must be positive for ascending)
                    const slope = (point2.price - point1.price) / (point2.index - point1.index);
                    if (slope <= 0) continue;
                    
                    // Check angle (not too steep)
                    const angle = Math.atan(slope * 100) * (180 / Math.PI); // Convert to degrees
                    if (angle > maxAngle) continue;
                    
                    // Calculate trendline equation: y = mx + b
                    const intercept = point1.price - (slope * point1.index);
                    
                    // Find all points that touch this trendline
                    const touchingPoints = findPointsOnTrendline(historicalData, slope, intercept, 'low', 0.02);
                    
                    if (touchingPoints.length >= minTouches) {
                        const trendline = {
                            type: 'ascending',
                            slope: +slope.toFixed(6),
                            intercept: +intercept.toFixed(2),
                            startPoint: point1,
                            endPoint: point2,
                            touches: touchingPoints.length,
                            strength: touchingPoints.length >= 4 ? 'Strong' : touchingPoints.length >= 3 ? 'Moderate' : 'Weak',
                            touchingPoints: touchingPoints,
                            angle: +angle.toFixed(1)
                        };
                        trendlines.push(trendline);
                    }
                }
            }
            
            // Sort by number of touches and return best ones
            return trendlines.sort((a, b) => b.touches - a.touches).slice(0, 3);
        }

        function findDescendingTrendlines(highs, historicalData) {
            const trendlines = [];
            const minTouches = 2;
            const maxAngle = 45; // Maximum angle in degrees
            
            for (let i = 0; i < highs.length - 1; i++) {
                for (let j = i + 1; j < highs.length; j++) {
                    const point1 = highs[i];
                    const point2 = highs[j];
                    
                    // Calculate slope (must be negative for descending)
                    const slope = (point2.price - point1.price) / (point2.index - point1.index);
                    if (slope >= 0) continue;
                    
                    // Check angle (not too steep)
                    const angle = Math.abs(Math.atan(slope * 100) * (180 / Math.PI)); // Convert to degrees
                    if (angle > maxAngle) continue;
                    
                    // Calculate trendline equation: y = mx + b
                    const intercept = point1.price - (slope * point1.index);
                    
                    // Find all points that touch this trendline
                    const touchingPoints = findPointsOnTrendline(historicalData, slope, intercept, 'high', 0.02);
                    
                    if (touchingPoints.length >= minTouches) {
                        const trendline = {
                            type: 'descending',
                            slope: +slope.toFixed(6),
                            intercept: +intercept.toFixed(2),
                            startPoint: point1,
                            endPoint: point2,
                            touches: touchingPoints.length,
                            strength: touchingPoints.length >= 4 ? 'Strong' : touchingPoints.length >= 3 ? 'Moderate' : 'Weak',
                            touchingPoints: touchingPoints,
                            angle: +angle.toFixed(1)
                        };
                        trendlines.push(trendline);
                    }
                }
            }
            
            // Sort by number of touches and return best ones
            return trendlines.sort((a, b) => b.touches - a.touches).slice(0, 3);
        }

        function findPointsOnTrendline(historicalData, slope, intercept, priceType, tolerance) {
            const touchingPoints = [];
            
            for (let i = 0; i < historicalData.length; i++) {
                const dataPoint = historicalData[i];
                const expectedPrice = slope * i + intercept;
                const actualPrice = priceType === 'high' ? dataPoint.high : dataPoint.low;
                
                // Check if point is close to trendline
                const priceDifference = Math.abs(actualPrice - expectedPrice) / expectedPrice;
                if (priceDifference <= tolerance) {
                    touchingPoints.push({
                        index: i,
                        date: dataPoint.date,
                        price: actualPrice,
                        expectedPrice: +expectedPrice.toFixed(2),
                        difference: +priceDifference.toFixed(4)
                    });
                }
            }
            
            return touchingPoints;
        }

        function calculateTrendlinePrice(trendline, index) {
            return +(trendline.slope * index + trendline.intercept).toFixed(2);
        }

        function detectTrendlineBreaks(trendlines, historicalData) {
            const breaks = [];
            const currentPrice = historicalData[historicalData.length - 1].close;
            const currentIndex = historicalData.length - 1;
            
            // Check ascending trendline breaks (price below trendline)
            trendlines.ascending.forEach(trendline => {
                const currentTrendlinePrice = calculateTrendlinePrice(trendline, currentIndex);
                if (currentPrice < currentTrendlinePrice * 0.98) { // 2% below trendline
                    breaks.push({
                        type: 'ascending_break',
                        trendline: trendline,
                        currentPrice: currentPrice,
                        trendlinePrice: currentTrendlinePrice,
                        breakPercentage: +((1 - currentPrice/currentTrendlinePrice) * 100).toFixed(2)
                    });
                }
            });
            
            // Check descending trendline breaks (price above trendline)
            trendlines.descending.forEach(trendline => {
                const currentTrendlinePrice = calculateTrendlinePrice(trendline, currentIndex);
                if (currentPrice > currentTrendlinePrice * 1.02) { // 2% above trendline
                    breaks.push({
                        type: 'descending_break',
                        trendline: trendline,
                        currentPrice: currentPrice,
                        trendlinePrice: currentTrendlinePrice,
                        breakPercentage: +((currentPrice/currentTrendlinePrice - 1) * 100).toFixed(2)
                    });
                }
            });
            
            return breaks;
        }

        function findSupportResistanceLevels(historicalData) {
            const levels = {
                supportLevels: [],
                resistanceLevels: [],
                strongestSupport: null,
                strongestResistance: null,
                currentSupport: null,
                currentResistance: null
            };

            // Get all significant highs and lows
            const swingPoints = findSwingPoints(historicalData);
            
            // Group similar price levels (within 2% of each other)
            const supportClusters = findPriceClusters(swingPoints.lows, 0.02);
            const resistanceClusters = findPriceClusters(swingPoints.highs, 0.02);
            
            // Convert clusters to support/resistance levels
            levels.supportLevels = supportClusters.map(cluster => ({
                price: cluster.avgPrice,
                touches: cluster.points.length,
                strength: cluster.points.length >= 3 ? 'Strong' : cluster.points.length >= 2 ? 'Moderate' : 'Weak',
                dates: cluster.points.map(p => p.date),
                volumes: cluster.points.map(p => p.volume)
            })).sort((a, b) => b.price - a.price);

            levels.resistanceLevels = resistanceClusters.map(cluster => ({
                price: cluster.avgPrice,
                touches: cluster.points.length,
                strength: cluster.points.length >= 3 ? 'Strong' : cluster.points.length >= 2 ? 'Moderate' : 'Weak',
                dates: cluster.points.map(p => p.date),
                volumes: cluster.points.map(p => p.volume)
            })).sort((a, b) => a.price - b.price);

            // Find strongest levels
            levels.strongestSupport = levels.supportLevels.reduce((strongest, level) => 
                !strongest || level.touches > strongest.touches ? level : strongest, null);
            
            levels.strongestResistance = levels.resistanceLevels.reduce((strongest, level) => 
                !strongest || level.touches > strongest.touches ? level : strongest, null);

            // Find current nearest levels
            const currentPrice = historicalData[historicalData.length - 1].close;
            levels.currentSupport = levels.supportLevels.find(level => level.price < currentPrice);
            levels.currentResistance = levels.resistanceLevels.find(level => level.price > currentPrice);

            // Calculate stop loss and take profit levels
            if (levels.currentSupport) {
                levels.stopLoss = +(levels.currentSupport.price * 0.98).toFixed(2);
            }
            if (levels.currentResistance) {
                levels.takeProfit = +(levels.currentResistance.price * 0.98).toFixed(2);
            }

            return levels;
        }

        function findSwingPoints(historicalData, period = 5) {
            const highs = [];
            const lows = [];

            for (let i = period; i < historicalData.length - period; i++) {
                const current = historicalData[i];
                let isHigh = true;
                let isLow = true;

                // Check if current point is a swing high or low
                for (let j = i - period; j <= i + period; j++) {
                    if (j === i) continue;
                    if (historicalData[j].high > current.high) isHigh = false;
                    if (historicalData[j].low < current.low) isLow = false;
                }

                if (isHigh) {
                    highs.push({
                        price: current.high,
                        date: current.date,
                        volume: current.volume,
                        index: i
                    });
                }

                if (isLow) {
                    lows.push({
                        price: current.low,
                        date: current.date,
                        volume: current.volume,
                        index: i
                    });
                }
            }

            return { highs, lows };
        }

        function findPriceClusters(points, tolerance = 0.02) {
            const clusters = [];
            const used = new Set();

            for (let i = 0; i < points.length; i++) {
                if (used.has(i)) continue;

                const cluster = {
                    points: [points[i]],
                    avgPrice: points[i].price
                };

                // Find all points within tolerance
                for (let j = i + 1; j < points.length; j++) {
                    if (used.has(j)) continue;
                    
                    const priceDiff = Math.abs(points[j].price - cluster.avgPrice) / cluster.avgPrice;
                    if (priceDiff <= tolerance) {
                        cluster.points.push(points[j]);
                        used.add(j);
                    }
                }

                // Recalculate average price
                cluster.avgPrice = +(cluster.points.reduce((sum, p) => sum + p.price, 0) / cluster.points.length).toFixed(2);
                
                // Only include clusters with at least 2 touches
                if (cluster.points.length >= 2) {
                    clusters.push(cluster);
                }
                
                used.add(i);
            }

            return clusters.sort((a, b) => b.points.length - a.points.length);
        }

        function analyzeTrend(historicalData) {
            const recentData = historicalData.slice(-30); // Last 30 days
            const olderData = historicalData.slice(-60, -30); // Previous 30 days
            
            const recentAvg = recentData.reduce((sum, d) => sum + d.close, 0) / recentData.length;
            const olderAvg = olderData.reduce((sum, d) => sum + d.close, 0) / olderData.length;
            
            const trendChange = ((recentAvg - olderAvg) / olderAvg) * 100;
            
            let currentTrend = 'sideways';
            let trendStrength = 50;
            
            if (trendChange > 2) {
                currentTrend = 'uptrend';
                trendStrength = Math.min(75 + (trendChange * 2), 95);
            } else if (trendChange < -2) {
                currentTrend = 'downtrend';
                trendStrength = Math.min(75 + (Math.abs(trendChange) * 2), 95);
            } else {
                trendStrength = 60 - Math.abs(trendChange * 5);
            }

            // Calculate volatility
            const prices = recentData.map(d => d.close);
            const volatility = calculateVolatility(prices);
            
            return {
                currentTrend,
                trendStrength: Math.round(trendStrength),
                trendChange: +trendChange.toFixed(2),
                volatility: +volatility.toFixed(2),
                avgVolume: Math.round(recentData.reduce((sum, d) => sum + d.volume, 0) / recentData.length)
            };
        }

        function calculateVolatility(prices) {
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
                returns.push((prices[i] - prices[i-1]) / prices[i-1]);
            }
            
            const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
            
            return Math.sqrt(variance) * Math.sqrt(252) * 100; // Annualized volatility as percentage
        }

        function getStrategyAnalysisWithTrendlines(currentData, levels, trendlines, trendAnalysis, strategy) {
            const analysis = {
                signals: [],
                recommendation: 'WAIT',
                riskLevel: 'Medium'
            };

            const currentPrice = currentData.currentPrice;
            const nearestSupport = levels.currentSupport;
            const nearestResistance = levels.currentResistance;
            const nearestAscending = trendlines.nearestAscending;
            const nearestDescending = trendlines.nearestDescending;
            const trendlineBreaks = trendlines.trendlineBreaks;

            // Check for trendline breaks first (high priority signals)
            if (trendlineBreaks.length > 0) {
                trendlineBreaks.forEach(breakInfo => {
                    if (breakInfo.type === 'ascending_break') {
                        analysis.signals.push(`üîª TRENDLINE BREAK: Price broke ${breakInfo.breakPercentage}% below ascending trendline at $${breakInfo.trendlinePrice}`);
                        if (strategy === 'breakout' || strategy === 'trend') {
                            analysis.recommendation = 'SELL/SHORT';
                            analysis.riskLevel = 'Medium';
                        }
                    } else if (breakInfo.type === 'descending_break') {
                        analysis.signals.push(`üî∫ TRENDLINE BREAKOUT: Price broke ${breakInfo.breakPercentage}% above descending trendline at $${breakInfo.trendlinePrice}`);
                        if (strategy === 'breakout' || strategy === 'trend') {
                            analysis.recommendation = 'BUY';
                            analysis.riskLevel = 'Medium';
                        }
                    }
                });
            }

            // Strategy-specific analysis incorporating trendlines
            switch (strategy) {
                case 'range':
                    if (nearestSupport && currentPrice <= nearestSupport.price * 1.03) {
                        analysis.signals.push(`Near REAL support at $${nearestSupport.price} (${nearestSupport.touches} touches)`);
                        if (nearestAscending && currentPrice >= nearestAscending.currentPrice * 0.98) {
                            analysis.signals.push(`üî∫ CONFLUENCE: Support + ascending trendline at $${nearestAscending.currentPrice}`);
                            analysis.recommendation = 'STRONG BUY';
                            analysis.riskLevel = 'Low';
                        } else {
                            analysis.recommendation = 'BUY';
                            analysis.riskLevel = nearestSupport.strength === 'Strong' ? 'Low' : 'Medium';
                        }
                    } else if (nearestResistance && currentPrice >= nearestResistance.price * 0.97) {
                        analysis.signals.push(`Near REAL resistance at $${nearestResistance.price} (${nearestResistance.touches} touches)`);
                        if (nearestDescending && currentPrice <= nearestDescending.currentPrice * 1.02) {
                            analysis.signals.push(`üîª CONFLUENCE: Resistance + descending trendline at $${nearestDescending.currentPrice}`);
                            analysis.recommendation = 'STRONG SELL';
                            analysis.riskLevel = 'Low';
                        } else {
                            analysis.recommendation = 'SELL';
                            analysis.riskLevel = nearestResistance.strength === 'Strong' ? 'Low' : 'Medium';
                        }
                    }
                    break;

                case 'breakout':
                    if (nearestResistance && currentPrice > nearestResistance.price) {
                        analysis.signals.push(`BREAKOUT above $${nearestResistance.price} resistance (${nearestResistance.touches} touches)`);
                        analysis.recommendation = 'BUY';
                        analysis.riskLevel = 'Medium';
                    } else if (nearestSupport && currentPrice < nearestSupport.price) {
                        analysis.signals.push(`BREAKDOWN below $${nearestSupport.price} support (${nearestSupport.touches} touches)`);
                        analysis.recommendation = 'SELL';
                        analysis.riskLevel = 'Medium';
                    }
                    break;

                case 'trend':
                    if (nearestAscending && currentPrice >= nearestAscending.currentPrice * 0.97) {
                        analysis.signals.push(`üî∫ Following ascending trendline: $${nearestAscending.currentPrice} (${nearestAscending.touches} touches, ${nearestAscending.strength})`);
                        analysis.recommendation = 'BUY on dips';
                        analysis.riskLevel = 'Low';
                    } else if (nearestDescending && currentPrice <= nearestDescending.currentPrice * 1.03) {
                        analysis.signals.push(`üîª Following descending trendline: $${nearestDescending.currentPrice} (${nearestDescending.touches} touches, ${nearestDescending.strength})`);
                        analysis.recommendation = 'SELL on bounces';
                        analysis.riskLevel = 'Low';
                    } else if (trendAnalysis.currentTrend === 'uptrend' && trendAnalysis.trendStrength > 70) {
                        analysis.signals.push(`Strong ${trendAnalysis.currentTrend} with ${trendAnalysis.trendStrength}% confidence`);
                        analysis.recommendation = 'BUY on dips';
                        analysis.riskLevel = 'Low';
                    } else if (trendAnalysis.currentTrend === 'downtrend' && trendAnalysis.trendStrength > 70) {
                        analysis.signals.push(`Strong ${trendAnalysis.currentTrend} with ${trendAnalysis.trendStrength}% confidence`);
                        analysis.recommendation = 'SELL on bounces';
                        analysis.riskLevel = 'Low';
                    }
                    break;

                case 'reversal':
                    if (trendlineBreaks.length > 0) {
                        analysis.signals.push(`Trendline break detected - potential trend reversal`);
                        analysis.riskLevel = 'High';
                    }
                    if (trendAnalysis.volatility > 30 && Math.abs(currentData.changePercent) > 3) {
                        const direction = currentData.change < 0 ? 'UP' : 'DOWN';
                        analysis.signals.push(`High volatility (${trendAnalysis.volatility}%) + ${Math.abs(currentData.changePercent)}% move = potential reversal ${direction}`);
                        analysis.recommendation = direction === 'UP' ? 'BUY reversal' : 'SELL reversal';
                        analysis.riskLevel = 'High';
                    }
                    break;
            }

            return analysis;
        }

        function displayStocks() {
            const container = document.getElementById('stocksContainer');
            if (trackedStocks.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">
                        <h3>No stocks being tracked yet</h3>
                        <p>Add a stock above to start tracking with CORS-friendly APIs and complete analysis</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = trackedStocks.map((stock, index) => {
                const data = stock.data;
                const analysis = stock.analysis;
                const levels = analysis.levels;
                const trendlines = analysis.trendlines || {};

                return `
                    <div class="stock-card">
                        <div class="stock-header">
                            <button class="remove-btn" onclick="removeStock(${index})">Remove</button>
                            <div class="stock-symbol">${data.symbol}</div>
                            <div class="stock-price">$${data.currentPrice} 
                                <span style="font-size: 0.8em; opacity: 0.8;">
                                    (${data.change >= 0 ? '+' : ''}${data.change} / ${data.changePercent}%)
                                </span>
                            </div>
                            <div class="api-status">
                                ‚úÖ Real API Keys Active ‚Ä¢ Twelve Data + Polygon.io ‚Ä¢ Full historical analysis
                            </div>
                            <div class="historical-info">
                                üìä Analyzed ${stock.historicalData?.length || 0} days ‚Ä¢ 
                                ${levels.supportLevels?.length || 0} support ‚Ä¢ 
                                ${levels.resistanceLevels?.length || 0} resistance levels
                            </div>
                            <div class="trendline-info">
                                üìà Found ${(trendlines && trendlines.ascending) ? trendlines.ascending.length : 0} ascending + ${(trendlines && trendlines.descending) ? trendlines.descending.length : 0} descending trendlines ‚Ä¢ 
                                ${(trendlines && trendlines.activeTrendlines) ? trendlines.activeTrendlines : 0} currently active
                            </div>
                            <a href="https://finviz.com/quote.ashx?t=${data.symbol}" target="_blank" class="chart-link">
                                üìä View Chart on Finviz
                            </a>
                        </div>
                        <div class="stock-body">
                            <div class="strategy-box">
                                <h5>üìã Strategy: ${analysis.strategy.toUpperCase()}</h5>
                                <strong>Recommendation: ${analysis.recommendation}</strong><br>
                                Risk Level: <span class="${analysis.riskLevel.toLowerCase()}">${analysis.riskLevel}</span><br>
                                Trend: ${analysis.historicalAnalysis?.currentTrend || 'Unknown'} 
                                (${analysis.historicalAnalysis?.trendStrength || 0}% confidence)
                            </div>

                            ${generateAlertsWithTrendlines(stock)}

                            <div class="analysis-section">
                                <h4>üìä Technical Analysis Signals</h4>
                                ${analysis.signals.map(signal => {
                                    if (signal.includes('TRENDLINE')) {
                                        return `<div class="analysis-item trendline-break">${signal}</div>`;
                                    } else if (signal.includes('CONFLUENCE')) {
                                        return `<div class="analysis-item strong">${signal}</div>`;
                                    } else if (signal.includes('üî∫') || signal.includes('üîª')) {
                                        return `<div class="analysis-item trendline">${signal}</div>`;
                                    } else {
                                        return `<div class="analysis-item">${signal}</div>`;
                                    }
                                }).join('')}
                            </div>

                            <div class="analysis-section">
                                <h4>üìà Active Trendlines</h4>
                                ${(trendlines && trendlines.nearestAscending) ? 
                                    `<div class="analysis-item trendline">üî∫ Ascending: $${trendlines.nearestAscending.currentPrice} 
                                    (${trendlines.nearestAscending.touches} touches, ${trendlines.nearestAscending.strength}, ${trendlines.nearestAscending.angle}¬∞)</div>` : ''}
                                ${(trendlines && trendlines.nearestDescending) ? 
                                    `<div class="analysis-item trendline">üîª Descending: $${trendlines.nearestDescending.currentPrice} 
                                    (${trendlines.nearestDescending.touches} touches, ${trendlines.nearestDescending.strength}, ${trendlines.nearestDescending.angle}¬∞)</div>` : ''}
                                
                                ${(trendlines && trendlines.ascending) ? trendlines.ascending.slice(0, 2).map(tl => 
                                    `<div class="analysis-item trendline">Ascending TL: ${tl.touches} touches, ${tl.strength} (${tl.angle}¬∞)</div>`
                                ).join('') : ''}
                                
                                ${(trendlines && trendlines.descending) ? trendlines.descending.slice(0, 2).map(tl => 
                                    `<div class="analysis-item trendline">Descending TL: ${tl.touches} touches, ${tl.strength} (${tl.angle}¬∞)</div>`
                                ).join('') : ''}
                            </div>

                            <div class="analysis-section">
                                <h4>üéØ Key Horizontal Levels</h4>
                                ${levels.currentSupport ? 
                                    `<div class="analysis-item strong">üí™ Current Support: $${levels.currentSupport.price} 
                                    (${levels.currentSupport.touches} touches, ${levels.currentSupport.strength})</div>` : ''}
                                ${levels.currentResistance ? 
                                    `<div class="analysis-item strong">üí™ Current Resistance: $${levels.currentResistance.price} 
                                    (${levels.currentResistance.touches} touches, ${levels.currentResistance.strength})</div>` : ''}
                                
                                ${levels.stopLoss ? `<div class="analysis-item danger">üìç Horizontal Stop Loss: $${levels.stopLoss}</div>` : ''}
                                ${(trendlines && trendlines.stopLoss) ? `<div class="analysis-item danger">üìç Trendline Stop Loss: $${trendlines.stopLoss}</div>` : ''}
                                ${levels.takeProfit ? `<div class="analysis-item">üéØ Take Profit: $${levels.takeProfit}</div>` : ''}
                            </div>

                            <div class="douglas-principles">
                                <h5>üß† Mark Douglas Principles</h5>
                                <strong>Edge:</strong> ${analysis.douglasPrinciples.edge}<br>
                                <strong>Probability:</strong> ${analysis.douglasPrinciples.probability}<br>
                                <strong>Risk:</strong> ${analysis.douglasPrinciples.riskAcceptance}<br>
                                <strong>Execution:</strong> ${analysis.douglasPrinciples.execution}
                            </div>

                            <div class="last-updated">
                                Last updated: ${new Date(stock.lastUpdated).toLocaleString()}
                                <button class="btn" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;" 
                                        onclick="updateStock(${index})">üîÑ Update</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function generateAlertsWithTrendlines(stock) {
            const data = stock.data;
            const levels = stock.analysis.levels;
            const trendlines = stock.analysis.trendlines || {};
            const alerts = [];

            // Trendline break alerts (highest priority)
            if (trendlines.trendlineBreaks && trendlines.trendlineBreaks.length > 0) {
                trendlines.trendlineBreaks.forEach(breakInfo => {
                    if (breakInfo.type === 'ascending_break') {
                        alerts.push({
                            type: 'danger',
                            message: `üîª TRENDLINE BREAKDOWN: ${breakInfo.breakPercentage}% below ascending trendline!`,
                            action: `Consider SELL/SHORT - trendline support broken at $${breakInfo.trendlinePrice}`
                        });
                    } else if (breakInfo.type === 'descending_break') {
                        alerts.push({
                            type: 'success',
                            message: `üöÄ TRENDLINE BREAKOUT: ${breakInfo.breakPercentage}% above descending trendline!`,
                            action: `Consider BUY - resistance trendline broken at $${breakInfo.trendlinePrice}`
                        });
                    }
                });
            }

            // Trendline proximity alerts
            if (trendlines.nearestAscending && Math.abs(data.currentPrice - trendlines.nearestAscending.currentPrice) / trendlines.nearestAscending.currentPrice < 0.02) {
                alerts.push({
                    type: 'success',
                    message: `üî∫ Near Ascending Trendline: $${trendlines.nearestAscending.currentPrice}`,
                    action: `Potential BUY opportunity (${trendlines.nearestAscending.touches} touches, ${trendlines.nearestAscending.strength})`
                });
            }

            if (trendlines.nearestDescending && Math.abs(data.currentPrice - trendlines.nearestDescending.currentPrice) / trendlines.nearestDescending.currentPrice < 0.02) {
                alerts.push({
                    type: 'warning',
                    message: `üîª Near Descending Trendline: $${trendlines.nearestDescending.currentPrice}`,
                    action: `Watch for rejection (${trendlines.nearestDescending.touches} touches, ${trendlines.nearestDescending.strength})`
                });
            }

            // Horizontal level alerts
            if (levels.currentSupport && Math.abs(data.currentPrice - levels.currentSupport.price) / levels.currentSupport.price < 0.02) {
                alerts.push({
                    type: 'info',
                    message: `üéØ Near ${levels.currentSupport.strength} Support: $${levels.currentSupport.price}`,
                    action: `Potential BUY opportunity (tested ${levels.currentSupport.touches} times)`
                });
            }

            if (levels.currentResistance && Math.abs(data.currentPrice - levels.currentResistance.price) / levels.currentResistance.price < 0.02) {
                alerts.push({
                    type: 'warning',
                    message: `‚ö†Ô∏è Near ${levels.currentResistance.strength} Resistance: $${levels.currentResistance.price}`,
                    action: `Watch for rejection (tested ${levels.currentResistance.touches} times)`
                });
            }

            if (alerts.length === 0) {
                return '<div class="alert info">‚úÖ No immediate action - monitoring trendlines and key levels</div>';
            }

            return alerts.map(alert => `
                <div class="alert ${alert.type}">
                    ${alert.message}<br>
                    <strong>Action:</strong> ${alert.action}
                </div>
            `).join('');
        }

        async function updateStock(index) {
            try {
                const stock = trackedStocks[index];
                const newCurrentData = await fetchCurrentDataCORSFriendly(stock.symbol);
                const newAnalysis = analyzeStockWithHistoryAndTrendlines(newCurrentData, stock.historicalData, stock.strategy);
                
                trackedStocks[index] = {
                    ...stock,
                    data: newCurrentData,
                    analysis: newAnalysis,
                    lastUpdated: new Date().toISOString()
                };
                saveTrackedStocks();
                displayStocks();
            } catch (error) {
                alert('Error updating stock: ' + error.message);
            }
        }

        function removeStock(index) {
            if (confirm('Are you sure you want to remove this stock from tracking?')) {
                trackedStocks.splice(index, 1);
                saveTrackedStocks();
                displayStocks();
            }
        }

        async function checkAllStocksForAlerts() {
            for (let i = 0; i < trackedStocks.length; i++) {
                await updateStock(i);
            }
        }

        // Allow Enter key to add stock
        document.addEventListener('DOMContentLoaded', function() {
            const stockInput = document.getElementById('stockSymbol');
            if (stockInput) {
                stockInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') addStock();
                });
            }
        });
    </script>
</body>
</html>
